DO $$
DECLARE
  v_schema text := current_schema();

  r_parent RECORD;
  r_fk     RECORD;

  exists_col boolean;
  exists_idx boolean;
  exists_fk  boolean;

  idx_name     text;
  new_fk_name  text;
  child_col2   text;
  next_start   bigint;
BEGIN
  RAISE NOTICE 'Esquema objetivo: %', v_schema;

  ---------------------------------------------------------------------------
  -- 1) PADRES: tablas con PK simple "id" tipo int4
  ---------------------------------------------------------------------------
  CREATE TEMP TABLE _parents ON COMMIT DROP AS
  SELECT
    n.nspname   AS schema_name,
    c.relname   AS table_name,
    con.conname AS pk_name
  FROM pg_constraint con
  JOIN pg_class     c ON c.oid = con.conrelid
  JOIN pg_namespace n ON n.oid = c.relnamespace
  JOIN pg_index     i ON i.indrelid = c.oid AND i.indisprimary
  JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(i.indkey)
  WHERE con.contype='p'
    AND n.nspname = v_schema
    AND array_length(i.indkey,1)=1
    AND a.attname = 'id'
    AND a.atttypid = 'int4'::regtype;

  IF NOT EXISTS (SELECT 1 FROM _parents) THEN
    RAISE NOTICE 'No hay PK(id int) para migrar en %', v_schema;
    RETURN;
  END IF;

  ---------------------------------------------------------------------------
  -- 2) FKs HIJAS que referencian esas PK(id)
  ---------------------------------------------------------------------------
  CREATE TEMP TABLE _fk_tasks ON COMMIT DROP AS
  SELECT
    con.oid          AS con_oid,
    nc.nspname       AS child_schema,
    cc.relname       AS child_table,
    con.conname      AS old_fk_name,
    np.nspname       AS parent_schema,
    cp.relname       AS parent_table,
    attp.attname     AS parent_col,   -- 'id'
    attc.attname     AS child_col     -- ej 'player_id'
  FROM pg_constraint con
  JOIN pg_class     cc ON cc.oid = con.conrelid
  JOIN pg_namespace nc ON nc.oid = cc.relnamespace
  JOIN pg_class     cp ON cp.oid = con.confrelid
  JOIN pg_namespace np ON np.oid = cp.relnamespace
  JOIN LATERAL unnest(con.conkey)  WITH ORDINALITY ck(k, pos) ON TRUE
  JOIN LATERAL unnest(con.confkey) WITH ORDINALITY pk(k, pos) ON pk.pos=ck.pos
  JOIN pg_attribute attc ON attc.attrelid = cc.oid AND attc.attnum = ck.k
  JOIN pg_attribute attp ON attp.attrelid = cp.oid AND attp.attnum = pk.k
  JOIN _parents p
    ON p.schema_name = np.nspname AND p.table_name = cp.relname
  WHERE con.contype='f'
    AND attp.attname='id';

  ---------------------------------------------------------------------------
  -- 3) PADRES: agregar id2 BIGINT, copiar, identity y unique index
  ---------------------------------------------------------------------------
  FOR r_parent IN SELECT * FROM _parents ORDER BY table_name LOOP
    -- ¿ya existe id2?
    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema=r_parent.schema_name AND table_name=r_parent.table_name AND column_name='id2'
    ) INTO exists_col;

    IF NOT exists_col THEN
      EXECUTE format('ALTER TABLE %I.%I ADD COLUMN id2 BIGINT',
                     r_parent.schema_name, r_parent.table_name);
      EXECUTE format('UPDATE %I.%I SET id2 = id',
                     r_parent.schema_name, r_parent.table_name);
      EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN id2 SET NOT NULL',
                     r_parent.schema_name, r_parent.table_name);
      -- convertir en IDENTITY
      EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN id2 ADD GENERATED BY DEFAULT AS IDENTITY',
                     r_parent.schema_name, r_parent.table_name);

      -- Ajustar contador al MAX(id2)+1 (válido para identity y serial)
      EXECUTE format('SELECT COALESCE(MAX(id2),0)+1 FROM %I.%I',
                     r_parent.schema_name, r_parent.table_name)
        INTO next_start;

      EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN id2 RESTART WITH %s',
                     r_parent.schema_name, r_parent.table_name, next_start);

      RAISE NOTICE 'Padre %.%: id2 creado/copiao; RESTART WITH %', r_parent.schema_name, r_parent.table_name, next_start;
    END IF;

    -- Índice único para enganchar la PK luego
    idx_name := r_parent.table_name || '_id2_uidx';
    SELECT EXISTS (
      SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid=c.relnamespace
      WHERE n.nspname=r_parent.schema_name AND c.relname=idx_name AND c.relkind='i'
    ) INTO exists_idx;

    IF NOT exists_idx THEN
      EXECUTE format('CREATE UNIQUE INDEX %I ON %I.%I(id2)',
                     idx_name, r_parent.schema_name, r_parent.table_name);
      RAISE NOTICE 'Padre %.%: índice único % creado', r_parent.schema_name, r_parent.table_name, idx_name;
    END IF;
  END LOOP;

  ---------------------------------------------------------------------------
  -- 4) HIJAS: columna sombra, datos y FK nueva NOT VALID + VALIDATE
  ---------------------------------------------------------------------------
  FOR r_fk IN
    SELECT DISTINCT child_schema, child_table, old_fk_name, parent_schema, parent_table, child_col
    FROM _fk_tasks
    ORDER BY child_schema, child_table, old_fk_name
  LOOP
    child_col2 := r_fk.child_col || '2';

    -- agregar columna sombra si falta
    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema=r_fk.child_schema AND table_name=r_fk.child_table AND column_name=child_col2
    ) INTO exists_col;

    IF NOT exists_col THEN
      EXECUTE format('ALTER TABLE %I.%I ADD COLUMN %I BIGINT',
                     r_fk.child_schema, r_fk.child_table, child_col2);
      EXECUTE format('UPDATE %I.%I SET %I = %I::BIGINT',
                     r_fk.child_schema, r_fk.child_table, child_col2, r_fk.child_col);
      RAISE NOTICE 'Hija %.%: columna % creada y copiada',
        r_fk.child_schema, r_fk.child_table, child_col2;
    END IF;

    -- crear FK nueva si falta (apunta a id2)
    new_fk_name := r_fk.old_fk_name || '__newfk';
    SELECT EXISTS (
      SELECT 1 FROM pg_constraint con
      JOIN pg_class t ON t.oid=con.conrelid
      JOIN pg_namespace n ON n.oid=t.relnamespace
      WHERE con.contype='f' AND n.nspname=r_fk.child_schema
        AND t.relname=r_fk.child_table AND con.conname=new_fk_name
    ) INTO exists_fk;

    IF NOT exists_fk THEN
      EXECUTE format(
        'ALTER TABLE %I.%I ADD CONSTRAINT %I FOREIGN KEY (%I) REFERENCES %I.%I(id2) NOT VALID',
        r_fk.child_schema, r_fk.child_table, new_fk_name, child_col2, r_fk.parent_schema, r_fk.parent_table
      );
      EXECUTE format('ALTER TABLE %I.%I VALIDATE CONSTRAINT %I',
                     r_fk.child_schema, r_fk.child_table, new_fk_name);
      RAISE NOTICE 'Hija %.%: FK % creada y validada',
        r_fk.child_schema, r_fk.child_table, new_fk_name;
    END IF;
  END LOOP;

  ---------------------------------------------------------------------------
  -- 5) CUTOVER (orden correcto):
  --    5.1 Drop FKs VIEJAS que apuntan a parent(id)
  --    5.2 Mover PK del padre al índice de id2
  --    5.3 Renombrar __newfk -> nombre original
  --    5.4 Renombrar columnas (id -> id_old; id2 -> id; y en hijas)
  ---------------------------------------------------------------------------
  FOR r_parent IN SELECT * FROM _parents ORDER BY table_name LOOP
    idx_name := r_parent.table_name || '_id2_uidx';

    -- 5.1: primero, quitar FKs viejas dependientes de la PK
    FOR r_fk IN
      SELECT DISTINCT child_schema, child_table, old_fk_name, child_col
      FROM _fk_tasks
      WHERE parent_schema=r_parent.schema_name AND parent_table=r_parent.table_name
    LOOP
      SELECT EXISTS (
        SELECT 1 FROM pg_constraint con
        JOIN pg_class t ON t.oid=con.conrelid
        JOIN pg_namespace n ON n.oid=t.relnamespace
        WHERE con.contype='f' AND n.nspname=r_fk.child_schema
          AND t.relname=r_fk.child_table AND con.conname=r_fk.old_fk_name
      ) INTO exists_fk;

      IF exists_fk THEN
        EXECUTE format('ALTER TABLE %I.%I DROP CONSTRAINT %I',
                       r_fk.child_schema, r_fk.child_table, r_fk.old_fk_name);
      END IF;
    END LOOP;

    -- 5.2: ahora sí, mover la PK al índice de id2
    EXECUTE format('ALTER TABLE %I.%I DROP CONSTRAINT %I',
                   r_parent.schema_name, r_parent.table_name, r_parent.pk_name);
    EXECUTE format('ALTER TABLE %I.%I ADD CONSTRAINT %I PRIMARY KEY USING INDEX %I',
                   r_parent.schema_name, r_parent.table_name, r_parent.pk_name, idx_name);

    -- 5.3: renombrar FKs nuevas al nombre original
    FOR r_fk IN
      SELECT DISTINCT child_schema, child_table, old_fk_name, child_col
      FROM _fk_tasks
      WHERE parent_schema=r_parent.schema_name AND parent_table=r_parent.table_name
    LOOP
      IF EXISTS (
        SELECT 1 FROM pg_constraint con
        JOIN pg_class t ON t.oid=con.conrelid
        JOIN pg_namespace n ON n.oid=t.relnamespace
        WHERE con.contype='f' AND n.nspname=r_fk.child_schema
          AND t.relname=r_fk.child_table
          AND con.conname = r_fk.old_fk_name || '__newfk'
      ) THEN
        EXECUTE format('ALTER TABLE %I.%I RENAME CONSTRAINT %I TO %I',
                       r_fk.child_schema, r_fk.child_table,
                       r_fk.old_fk_name || '__newfk', r_fk.old_fk_name);
      END IF;

      -- 5.4.a: en hijas: col -> col_old ; col2 -> col
      child_col2 := r_fk.child_col || '2';

      IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema=r_fk.child_schema AND table_name=r_fk.child_table AND column_name=r_fk.child_col
      ) THEN
        IF EXISTS (
          SELECT 1 FROM information_schema.columns
          WHERE table_schema=r_fk.child_schema AND table_name=r_fk.child_table AND column_name=r_fk.child_col || '_old'
        ) THEN
          EXECUTE format('ALTER TABLE %I.%I DROP COLUMN %I',
                         r_fk.child_schema, r_fk.child_table, r_fk.child_col || '_old');
        END IF;
        EXECUTE format('ALTER TABLE %I.%I RENAME COLUMN %I TO %I',
                       r_fk.child_schema, r_fk.child_table, r_fk.child_col, r_fk.child_col || '_old');
      END IF;

      IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema=r_fk.child_schema AND table_name=r_fk.child_table AND column_name=child_col2
      ) THEN
        EXECUTE format('ALTER TABLE %I.%I RENAME COLUMN %I TO %I',
                       r_fk.child_schema, r_fk.child_table, child_col2, r_fk.child_col);
      END IF;
    END LOOP;

    -- 5.4.b: en padre: id -> id_old ; id2 -> id
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema=r_parent.schema_name AND table_name=r_parent.table_name AND column_name='id'
    ) THEN
      IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema=r_parent.schema_name AND table_name=r_parent.table_name AND column_name='id_old'
      ) THEN
        EXECUTE format('ALTER TABLE %I.%I DROP COLUMN id_old', r_parent.schema_name, r_parent.table_name);
      END IF;
      EXECUTE format('ALTER TABLE %I.%I RENAME COLUMN id TO id_old',
                     r_parent.schema_name, r_parent.table_name);
    END IF;

    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema=r_parent.schema_name AND table_name=r_parent.table_name AND column_name='id2'
    ) THEN
      EXECUTE format('ALTER TABLE %I.%I RENAME COLUMN id2 TO id',
                     r_parent.schema_name, r_parent.table_name);
    END IF;

  END LOOP;

  ---------------------------------------------------------------------------
  -- 6) LIMPIEZA: borrar TODAS las columnas *_old del esquema actual
  ---------------------------------------------------------------------------
  FOR r_parent IN
    SELECT table_schema, table_name, column_name
    FROM information_schema.columns
    WHERE table_schema = v_schema
      AND column_name LIKE '%\_old' ESCAPE '\'
  LOOP
    EXECUTE format('ALTER TABLE %I.%I DROP COLUMN %I',
                   r_parent.table_schema, r_parent.table_name, r_parent.column_name);
    RAISE NOTICE 'Dropped %.% column %', r_parent.table_schema, r_parent.table_name, r_parent.column_name;
  END LOOP;

  ---------------------------------------------------------------------------
  -- 7) Sincronizar IDENTITY de cada nueva PK(id) a MAX(id)+1
  ---------------------------------------------------------------------------
  FOR r_parent IN
    SELECT p.schema_name, p.table_name
    FROM _parents p
  LOOP
    EXECUTE format('SELECT COALESCE(MAX(id),0)+1 FROM %I.%I',
                   r_parent.schema_name, r_parent.table_name)
      INTO next_start;

    EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN id RESTART WITH %s',
                   r_parent.schema_name, r_parent.table_name, next_start);
    RAISE NOTICE 'Restart %.% id at %', r_parent.schema_name, r_parent.table_name, next_start;
  END LOOP;

  RAISE NOTICE 'Migración BIGINT + limpieza finalizada en esquema %', v_schema;
END $$;

-- Nota: el orden de columnas en pgAdmin no puede reordenarse; las nuevas siempre aparecen al final.
